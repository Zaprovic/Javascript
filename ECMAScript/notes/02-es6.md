# ECMAScript 6: One major update

All the updates since the beginning of ECMAScript were quite minor, and the functionality of the language was merly the same. It wasn't until 2015 that some game changing updates were introduce to the language. ECMAScript6 is today the JavaScript version that we are used to handle. 

## Scope: `let` and `const`
Recall that whenever we declare a variable in JavaScript, we need some reserved keywords. The OG way to do this was using `var`, but ES6 introduced two others: `let` and `const`.

Both `var` and `let` allow for re-initialization of variable, whereas `const` does not. Every variable declared with `const` *cannot change its initialization*.

But there is more about these keywords, and has to do with the scope of the variables. Lets consider the following function: 

```
const fruits = () => {
    if(true){
        var fruit1 = "Apple";
        let fruit2 = "Lemon";
        const fruit3 = "Cherry";
    }

    console.log(fruit1);
    console.log(fruit2);
    console.log(fruit3);
}
```

This leads to another difference among the keywords. Variables declared with `var` have a **function scope**, whereas `let` and `const` variables are only **accessible in their corresponding blocks**. Notice that `fruit2` and `fruit3` are declared with these last two, hence they can only be accesed from within if the if statement, whereas `fruit1` is accesible throughout the whole `fruits` function. 

The last major difference is that `let` variables **cannot be declared**, whereas `var` allows for this. 


## Arrow functions
This is a way to declare functions as variables themselves. It provides for a cleaner and consistent syntax

```
const square = (n) => {
	return n * n;
};
```
```
const cube = (n) => n * n * n;

```

## Template literals
The allow for string concatenation in a more flexible way

```
let hello = "Hello";
let world = "world";


// OG 
let phrase = hello + " " + world;

// ES6
let sentence = `${hello} ${world}`

```

Notice that template literals are another way to declare formatted strings. This is an awesome functionality, and very few languages can achieve this in such an easy way, like Python for example. Template literals also allow for *multiline strings*, rather than having to use `\n` . 

## Default parameters
In ES6 JavaScript allows for default parameters in a friendlier way

```
//OG
function newUSer(name, age, country) {
	var name = name || "default-name";
	var age = age || "default-age";
	var country = country || "default-country";
	console.log(name, age, country);
}

newUSer();
newUSer("Brandon", "Eich", "US");

```
```
//ES6
const userIn = (
	name = "default-name",
	age = "default-age",
	country = "default-country"
) => {
	console.log(name, age, country);
};

userIn();
userIn("Bjarne", "Strostroup", "DE");

```

## Destructuring assignment
It is not a secret that index notation is confusing, especially for early learners of programming, it makes no sense for us to start counting from 0 because it does not rigurously follow the definition of a natural number. In ES6 we can destruct an array using variables directly, instead of the index notation. 

```
// OG
var names = ["Brandon","Ryan"];
console.log(names[0],names[1]);
```

```
// ES6
let fruits = ["Apple", "Lemon"];
let [a, b] = fruits;
console.log(a, fruits[1]);
```
This syntax also allows for using index notation, so it is more flexible and it alsow works for objects

```
let user = { username: "brandon123", age: 40 };
let { username, age } = user;
console.log(username,age);
```

## Spread operators






 





